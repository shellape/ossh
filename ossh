#!/bin/bash 
# name:          ossh
# description:   List current ssh client connections and
#                establish a further one if requested.
# author:        vd@ghostshell.de
# version:       0.1
# tested on:     Debian Wheezy, Debian Jessie
# last modified: 2015-07
# vim: ts=3 sw=3 sts=3 et ai ci

set -e

#-----------------------
# Gloabl user variables
#-----------------------

HIST_FILE=~/.ossh_history
MAX_HIST_LINES=16
# Optional bash compatible regex for ssh connections which
# should not appear in the connection overview at all.
CONN_EXCL_RE='sshfs|sftp|scp| -fnN '
# Optional sed compatible expression to strip off a part of the ssh command
# in the connection overview. e.g. SSH_STRIP_EXPR='s/ .*foobar//'
SSH_STRIP_EXPR=''
# I you're using a wrapper to call ssh you can specify it here.
SSH_BIN=

# Above variables can also be sourced via include config.
INCLUDE_CONF=~/.ossh_include.conf
[[ -f $INCLUDE_CONF ]] && . $INCLUDE_CONF

#------------------------
# Other global variables
#------------------------

PROG_NAME=${0##*/}
ARGV=$@
VALIDATION_PATTERN='^([0-9]{1,3}){0,1}([+-][0-9]{1,3}){0,1}$'
AUTO_FLAG=false
LIST_FLAG=false

#-----------
# Functions
#-----------

usage() {
cat <<EOF
Usage: $PROG_NAME [index] [-l|--list] [-a|--auto] [-h|--help]
List or establish ssh connections.

Options:
 index      specify a numeric index to use from the overview, 
            e.g. "2" or "+3" or "4+1" or "-2" or "3-1"
 -l|--list  only list connections, do not a ask for a connection id
            (mutually exclusive with "index", supersedes "-a")
 -a|--auto  auto login if there is only one unique current connection
 -h|--help  show this help

EOF
}

parse_argv() {
   for arg in $ARGV; do
      if [[ $arg =~ ^(-h|--help)$ ]]; then
         usage
         exit
      elif [[ $arg =~ ^(-a|--auto)$ ]]; then
         AUTO_FLAG=true
      elif [[ $arg =~ ^(-l|--list)$ ]]; then
         LIST_FLAG=true
      elif [[ $arg =~ ^(-la|-al)$ ]]; then
         AUTO_FLAG=true
         LIST_FLAG=true
      elif [[ $arg =~ $VALIDATION_PATTERN ]]; then
         INDEX=$arg
      else
         echo "$arg: invalid parameter." >&2
         echo "Try '$PROG_NAME -h' for more information." >&2
         exit 1
      fi
   done

   if $AUTO_FLAG && $LIST_FLAG; then
      AUTO_FLAG=false
   fi

   if $LIST_FLAG && [[ -n $INDEX ]]; then
      echo "Specified parameters are mutually exclusive." >&2
      echo "Try \"$PROG_NAME -h\" for more information." >&2
      exit 1
   fi
}

create_hist_file() {
   local hist_basedir
   if [[ ! -e $HIST_FILE ]]; then
      hist_basedir=${HIST_FILE%/*}
      [[ ! -e $hist_basedir ]] && mkdir -p $hist_basedir
      touch $HIST_FILE
   fi
}

get_curr_conn() {
   local ps_list="$( ps -C ssh -o args hww )"
   if [[ -n $ps_list ]]; then
      while read ssh_client_cmd; do
         if [[ $ssh_client_cmd =~ ${CONN_EXCL_RE:-^$} ]]; then
            continue
         else
            CONN_ARR[ ${i:=0} ]="$ssh_client_cmd"
            i=$(( $i + 1 ))
         fi
      # Notice the use of process substition!
      done < <( echo "$ps_list" | sort -u )
   fi

}

check_conn_exists() {
   # Exit if no current or history connections available.
   if [[ -z $CONN_ARR ]] && [[ ! -s $HIST_FILE ]]; then
      echo "No current ssh connections and $HIST_FILE is empty." >&2
      exit 1
   fi
}

strip_off() {
   local line="$@"
   if [[ -n $SSH_STRIP_EXPR ]]; then
      echo "$line" | sed "$SSH_STRIP_EXPR"
   else
      echo "$line"
   fi
}

read_hist_file() {
   local conn_line hist_line duplicate
   if [[ -s $HIST_FILE ]]; then
      # Fill the history array.
      while read hist_line; do
         duplicate=false
         # Check if entry is already in conn array. If so skip.
         for x in ${!CONN_ARR[@]}; do
            conn_line="$( strip_off "${CONN_ARR[ $x ]}" )"
            if [[ $conn_line = $hist_line ]]; then
               duplicate=true
               break
            fi
         done
         if ! $duplicate; then
            HIST_ARR[ ${j:=0} ]="$hist_line"
            j=$(( $j + 1 ))
         fi
      done < $HIST_FILE
   fi
}

check_auto_flag() {
   if [[ ${#CONN_ARR[@]} -eq 1 ]] && $AUTO_FLAG; then
      INDEX=1
   fi
}

print_curr_conn() {
   check_auto_flag
   for x in ${!CONN_ARR[@]}; do
      if [[ -z $INDEX ]]; then
         strip_off $( printf "[%02d] %s\n" $(( $x + 1 )) "${CONN_ARR[ $x ]}" )
      fi
   done
}

print_hist_conn() {
   check_auto_flag
   if [[ -z $HIST_ARR ]] || [[ -n $INDEX ]]; then
      return
   fi
   echo '[--]'
   for i in "${!HIST_ARR[@]}"; do
      printf "[%02d] %s\n" $(( ${#CONN_ARR[@]} + $i + 1 )) "${HIST_ARR[ $i ]}"
   done
}

read_input() {
   $LIST_FLAG && exit
   # Check if there was an index passed directly or we have to read it.
   if [[ -n $INDEX ]]; then
      INPUT="$INDEX"
   else
      echo -n '>id: '
      read INPUT
   fi
}

validate_input() {
   if [[ ! $INPUT =~ $VALIDATION_PATTERN ]]; then
      echo "Invalid input." >&2
      usage
      exit 1
   fi
}

build_ssh_cmd() {
   local conn_id add_val ssh_client_cmd ip_addr last_oct new_last_oct new_ip_addr
   # Remove all leading zeros, example INPUT: "04+01".
   INPUT=$( echo $INPUT | sed 's/^0*//; s/+0*/+/; s/-0*/-/' )
   # Split off connection id and subtract 1 since array index starts with 0.
   conn_id=${INPUT%[+-]*}
   if [[ -n $conn_id ]] && [[ $conn_id -ne 0 ]]; then
      conn_id=$(( $conn_id - 1 ))
   fi
   # Check if arithm. operator given.
   if [[ $INPUT =~ [+-] ]]; then
      add_val=${INPUT#*[+-]}
      [[ $INPUT =~ - ]] && add_val="-$add_val"
   fi

   # Select the ssh command to be executed.
   # Distinguish to which array the id belongs.
   # Use id 0 if connection id is unset.
   if [[ -n $CONN_ARR ]] && [[ $conn_id -lt ${#CONN_ARR[@]} ]]; then
      ssh_client_cmd="${CONN_ARR[ ${conn_id:-0} ]}"
   # Check if id is in range.
   elif [[ $(( $conn_id + 1 )) -gt $(( ${#CONN_ARR[@]} + ${#HIST_ARR[@]} )) ]]; then
      echo "The id is out of range." >&2
      exit 1
   else
      # If there is no current connection or the id is out of
      # range of the connection array use the history array.
      conn_id=$(( $conn_id - ${#CONN_ARR[@]} ))
      ssh_client_cmd="${HIST_ARR[ ${conn_id:-0} ]}"
   fi

   if [[ -n $add_val ]]; then
      if ! ip_addr=$( echo $ssh_client_cmd | grep -Eo '([0-9]+\.){3}[0-9]+' ); then
         echo "Could not match an IPv4 in \"$ssh_client_cmd\"." >&2
         exit 1
      fi
      last_oct=${ip_addr##*.}
      new_last_oct=$(( $last_oct + $add_val ))
      new_ip_addr="${ip_addr%.*}.$new_last_oct"
      # Primitive sanity check.
      if [[ ! $new_last_oct -ge 1 ]] || [[ ! $new_last_oct -le 255 ]]; then
         echo "$new_last_oct not within meaningful IPv4 range." >&2
         exit 1
      fi
      # To stay MacOS compatible avoid the use of sed's "-r" parameter.
      SSH_LOGIN="$( echo "$ssh_client_cmd" \
                     | sed "s/[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*/$new_ip_addr/" )"
   else
      SSH_LOGIN="$ssh_client_cmd"
   fi
}

write_hist() {
   local stripped_ssh_login="$( strip_off "$SSH_LOGIN" )"

   if [[ -n $HIST_FILE ]] && [[ $MAX_HIST_LINES -gt 0 ]]; then
      {  for line in "${CONN_ARR[@]}"; do
            strip_off "$line"
         done
         for line in "${HIST_ARR[@]}"; do
            echo "$line"
         done }  \
            | sed '/^[ \t]*$/d' \
            | sort -ur \
            | head -n "$MAX_HIST_LINES" > $HIST_FILE
   fi
}

do_ssh_login() {
   if [[ -z $SSH_BIN ]]; then
      $SSH_LOGIN
   else
      SSH_LOGIN="$( echo "$SSH_LOGIN" | sed "s;ssh;$SSH_BIN;" )"
      $SSH_LOGIN
   fi
}

#------
# MAIN
#------

parse_argv
create_hist_file
get_curr_conn
check_conn_exists
read_hist_file
print_curr_conn
print_hist_conn
read_input
validate_input
build_ssh_cmd
write_hist
do_ssh_login
