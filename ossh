#!/bin/bash 
# name:          ossh
# description:   List current ssh client connections and
#                establish a further one if requested.
# author:        vd@ghostshell.de
# version:       0.1
# tested on:     Debian Wheezy, Debian Jessie
# last modified: 2015-12
# vim: ts=3 sw=3 sts=3 et ai ci

set -e

#-----------------------
# Gloabl user variables
#-----------------------

HIST_FILE=~/.ossh_history
MAX_HIST_LINES=16
# Optional bash compatible regex for ssh connections which
# should not appear in the connection overview at all.
CONN_EXCL_RE='sshfs|sftp|scp| -fnN '
# Optional sed compatible expression to strip off a part of the ssh command
# in the connection overview. e.g. SSH_STRIP_EXPR='s/ .*foobar//'
SSH_STRIP_EXPR=''
# I you're using a wrapper to call ssh you can specify it here.
SSH_BIN=''
# command parameters
PING_PARAM='-c3 -w10'
HOST_PARAM='-4 -t A'

# Above variables can also be sourced via include config.
INCLUDE_CONF=~/.ossh_include.conf
[[ -f $INCLUDE_CONF ]] && . $INCLUDE_CONF

#------------------------
# Other global variables
#------------------------

PROG_NAME=${0##*/}
ARGV=$@
# bash compatible regex
INDEX_REGEX='^p?$|^[0-9]{0,2}[+-]?[0-9]{1,3}p?$|^[0-9]{0,2}p?[+-]?[0-9]{1,3}$'
# grep and bash compatible extended regex
IP_V4_REGEX='([0-9]+\.){3}[0-9]+'
# grep compatible extended regex
FQDN_REGEX='[a-zA-Z0-9.-]{1,}\.[a-zA-Z]{2,}'
AUTO_FLAG=false
LIST_FLAG=false
PING_FLAG=false
TEST_FLAG=false

#-----------
# Functions
#-----------

usage() {
cat <<EOF
Usage: $PROG_NAME [-l|--list] [-a|--auto] [-h|--help] [index]

List or establish ssh connections.

Options:
 -l|--list  only list connections, do not a ask for a connection id
            (mutually exclusive with "index", supersedes "-a")
 -a|--auto  auto login (or ping) if there is only one unique current connection
            (superseded by "index")
 -h|--help  show this help
 index      specify a numeric index to use from the overview, e.g. "2" or "4"
            using +/- modifies ip's last octett of the choosen index, e.g. "+3" or "4-2"
            (appending "p" to "index" will just ping the ip, e.g. "2p" or "4+6p")

EOF
}

parse_argv() {
   for arg in $ARGV; do
      # Not documented test parameter (e.g. for contributors).
      # Passing an argument to "-t" just shows if the argument would be a valid "index".
      if [[ $arg = -t ]] || $TEST_FLAG; then
         if ! $TEST_FLAG; then
            TEST_FLAG=true
            continue
         fi
         if [[ $arg != -t ]]; then
            INPUT="$arg"
            validate_input
            cleanup_input
         fi
      fi
      # Have to work with if statements and regex to support short parameter without space delimiter.
      if [[ $arg =~ ^-(l|la|al|-list)$ ]]; then
         LIST_FLAG=true
      fi
      if [[ $arg =~ ^-(a|al|la|-auto)$ ]]; then
         AUTO_FLAG=true
      fi
      if [[ $arg =~ -h|--help ]]; then
         usage
         exit 0
      fi
      if [[ $arg =~ $INDEX_REGEX ]]; then
         if [[ -z $INDEX ]]; then
            INDEX=$arg
         else
            echo 'Passing "index" multiple times is not supported.' >&2
            printf '\nTry "%s -h" for help.\n' $PROG_NAME >&2
            exit 1
         fi
         if [[ $arg =~ p ]]; then
            PING_FLAG=true
         fi
      fi
      if [[ ! $arg =~ $INDEX_REGEX|^-(a|l|al|la|-list|-auto)$ ]]; then
         printf 'Unknown command line option: %s\n' $arg >&2
         printf '\nTry "%s -h" for help.\n' $PROG_NAME >&2
         exit 1
      fi
   done

   if $AUTO_FLAG && $LIST_FLAG; then
      AUTO_FLAG=false
   fi

   if $LIST_FLAG && [[ -n $INDEX ]]; then
      echo "Specified parameters are mutually exclusive." >&2
      printf '\nTry "%s -h" for help.\n' $PROG_NAME >&2
      exit 1
   fi
}

create_hist_file() {
   local hist_basedir
   if [[ ! -e $HIST_FILE ]]; then
      hist_basedir=${HIST_FILE%/*}
      [[ ! -e $hist_basedir ]] && mkdir -p $hist_basedir
      touch $HIST_FILE
   fi
}

get_curr_conn() {
   local ps_list="$( ps -eo args | grep '^ssh' )"
   if [[ -n $ps_list ]]; then
      while read ssh_client_cmd; do
         if [[ $ssh_client_cmd =~ ${CONN_EXCL_RE:-^$} ]]; then
            continue
         else
            CONN_ARR[ ${i:=0} ]="$ssh_client_cmd"
            i=$(( $i + 1 ))
         fi
      # Notice the use of process substition!
      done < <( echo "$ps_list" | sort -u )
   fi

}

check_conn_exists() {
   # Exit if no current or history connections available.
   if [[ -z $CONN_ARR ]] && [[ ! -s $HIST_FILE ]]; then
      echo "No current ssh connections and $HIST_FILE is empty." >&2
      exit 1
   fi
}

strip_off() {
   local line="$@"
   if [[ -n $SSH_STRIP_EXPR ]]; then
      echo "$line" | sed "$SSH_STRIP_EXPR"
   else
      echo "$line"
   fi
}

read_hist_file() {
   local conn_line hist_line duplicate
   if [[ -s $HIST_FILE ]]; then
      # Fill the history array.
      while read hist_line; do
         duplicate=false
         # Check if entry is already in conn array. If so skip.
         for x in ${!CONN_ARR[@]}; do
            conn_line="$( strip_off "${CONN_ARR[ $x ]}" )"
            if [[ $conn_line = $hist_line ]]; then
               duplicate=true
               break
            fi
         done
         if ! $duplicate; then
            HIST_ARR[ ${j:=0} ]="$hist_line"
            j=$(( $j + 1 ))
         fi
      done < $HIST_FILE
   fi
}

check_auto_flag() {
   if [[ ${#CONN_ARR[@]} -eq 1 ]] && $AUTO_FLAG && [[ -z $INDEX ]]; then
      INDEX=1
   fi
}

print_curr_conn() {
   check_auto_flag
   for x in ${!CONN_ARR[@]}; do
      if [[ -z $INDEX ]]; then
         strip_off $( printf "[%02d] %s\n" $(( $x + 1 )) "${CONN_ARR[ $x ]}" )
      fi
   done
}

print_hist_conn() {
   check_auto_flag
   if [[ -z $HIST_ARR ]] || [[ -n $INDEX ]]; then
      return
   fi
   echo '[--]'
   for i in "${!HIST_ARR[@]}"; do
      printf "[%02d] %s\n" $(( ${#CONN_ARR[@]} + $i + 1 )) "${HIST_ARR[ $i ]}"
   done
}

read_input() {
   $LIST_FLAG && exit
   # Check if there was an index passed directly or we have to read it.
   if [[ -n $INDEX ]]; then
      INPUT="$INDEX"
   else
      printf '%s: ' '>id'
      read INPUT
   fi
}

validate_input() {
   if [[ ! $INPUT =~ $INDEX_REGEX ]]; then
      if $TEST_FLAG; then
         printf 'invalid: %s, ' "$INPUT"
      else
         printf 'Invalid input: %s\n' "$INPUT" >&2
         printf '\nTry "%s -h" for help.\n' $PROG_NAME >&2
         exit 1
      fi
   else
      if $TEST_FLAG; then
         printf 'valid: %s, ' "$INPUT"
      fi
   fi
   if [[ $INPUT =~ p ]]; then
      INPUT=${INPUT/p/}
      PING_FLAG=true
   fi
}

cleanup_input() {
   # Remove all leading zeros, example INPUT: "04+01".
   INPUT=$( echo $INPUT \
            | sed 's/^0*//' \
            | sed 's/[+-]0*$//' \
            | sed 's/+0*/+/' \
            | sed 's/-0*/-/' )
   if $TEST_FLAG; then
     printf 'INPUT: %s, PING_FLAG: %s\n' "$INPUT" "$PING_FLAG"
     exit
   fi
}

get_ip_fqdn() {
   local line="$@"
   local ip_addr fqdn
   if ip_addr=$( echo $line | grep -Eo "$IP_V4_REGEX" ); then
      echo "$ip_addr"
   else
      if fqdn=$( echo $line | grep -Eo "$FQDN_REGEX" ); then
         ip_addr=$( host $HOST_PARAM $fqdn | awk 'NR==1{print $NF}' )
         if [[ ${PIPESTATUS[0]} != 0 ]]; then
            printf '\nCould not resolve IPv4 in "%s".\n' "$line" >&2
            exit 1
         fi
         if [[ $ip_addr =~ $IP_V4_REGEX ]]; then
            echo "$ip_addr $fqdn"
         else
            printf '\nCould not match an IPv4 in "%s".\n' "$ip_addr" >&2 
            exit 1
         fi
      else
         printf '\nCould not match an FQDN in "%s".\n' "$line" >&2   
         exit 1
      fi
   fi
}

build_action_cmd() {
   local conn_id add_val ssh_client_cmd ip_addr fqdn last_oct new_last_oct new_ip_addr
   # Split off connection id and subtract 1 since array index starts with 0.
   conn_id=${INPUT%[+-]*}
   if [[ -n $conn_id ]] && [[ $conn_id -ne 0 ]]; then
      conn_id=$(( $conn_id - 1 ))
   fi
   # Check if arithm. operator given.
   if [[ $INPUT =~ [+-] ]]; then
      add_val=${INPUT#*[+-]}
      [[ $INPUT =~ - ]] && add_val="-$add_val"
   fi

   # Select the ssh command to be executed.
   # Distinguish to which array the id belongs.
   # Use id 0 if connection id is unset.
   if [[ -n $CONN_ARR ]] && [[ $conn_id -lt ${#CONN_ARR[@]} ]]; then
      ssh_client_cmd="${CONN_ARR[ ${conn_id:-0} ]}"
   # Check if id is in range.
   elif [[ $(( $conn_id + 1 )) -gt $(( ${#CONN_ARR[@]} + ${#HIST_ARR[@]} )) ]]; then
      echo "The id is out of range." >&2
      exit 1
   else
      # If there is no current connection or the id is out of
      # range of the connection array use the history array.
      conn_id=$(( $conn_id - ${#CONN_ARR[@]} ))
      ssh_client_cmd="${HIST_ARR[ ${conn_id:-0} ]}"
   fi

   if [[ -n $add_val ]]; then
      read ip_addr fqdn < <( get_ip_fqdn $ssh_client_cmd )
      last_oct=${ip_addr##*.}
      new_last_oct=$(( $last_oct + $add_val ))
      new_ip_addr="${ip_addr%.*}.$new_last_oct"
      # Primitive sanity check.
      if [[ ! $new_last_oct -ge 1 ]] || [[ ! $new_last_oct -le 255 ]]; then
         echo '\n%s not within meaningful IPv4 range.' "$new_last_oct" >&2
         exit 1
      fi
      if [[ -n $fqdn ]]; then 
         SSH_LOGIN="$( echo "$ssh_client_cmd" | sed "s/$fqdn/$new_ip_addr/" )"
      else
         # To stay MacOS compatible avoid the use of sed's "-r" parameter.
         SSH_LOGIN="$( echo "$ssh_client_cmd" \
                        | sed "s/[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*/$new_ip_addr/" )"
      fi
   else
      SSH_LOGIN="$ssh_client_cmd"
   fi

   if $PING_FLAG; then
      if [[ -n $new_ip_addr ]]; then
         ip_addr=$new_ip_addr
      else
         read ip_addr fqdn < <( get_ip_fqdn $ssh_client_cmd )
         # Since there was no operation on FQDN keep it visual
         # for the user (if set) and let ping resolve the address.
         ip_addr=${fqdn:-$ip_addr}
      fi
      PING_CMD="ping $PING_PARAM $ip_addr"
   fi
}

write_hist() {
   $PING_FLAG && return
   local stripped_ssh_login="$( strip_off "$SSH_LOGIN" )"

   if [[ -n $HIST_FILE ]] && [[ $MAX_HIST_LINES -gt 0 ]]; then
      {  for line in "${CONN_ARR[@]}"; do
            strip_off "$line"
         done
         for line in "${HIST_ARR[@]}"; do
            echo "$line"
         done }  \
            | sed '/^[ \t]*$/d' \
            | sort -ur \
            | head -n "$MAX_HIST_LINES" > $HIST_FILE
   fi
}

exec_action_cmd() {
   if $PING_FLAG; then
      echo
      $PING_CMD
      exit $?
   fi
   if [[ -z $SSH_BIN ]]; then
      $SSH_LOGIN
   else
      SSH_LOGIN="$( echo "$SSH_LOGIN" | sed "s;ssh;$SSH_BIN;" )"
      $SSH_LOGIN
   fi
}

#------
# MAIN
#------

parse_argv
create_hist_file
get_curr_conn
check_conn_exists
read_hist_file
print_curr_conn
print_hist_conn
read_input
validate_input
cleanup_input
build_action_cmd
write_hist
exec_action_cmd
